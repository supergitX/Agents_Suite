# 🤖 Agents Suite Demo

This project demonstrates an automated code generation, review, optimization, and testing workflow using Gemini and Groq large language models (LLMs) within a GitHub Actions environment. A user provides a prompt in `input.txt`, which is used to generate Python code. This generated code (`generated_code/generated.py` which is copied to `buggy_code.py`) is then automatically reviewed, and the review is used to create an optimized version (`reviewed_code.py`). Finally, tests are generated and run against the reviewed code. The entire process is managed through GitHub Actions workflows. The project also includes a documentation generation component using Gemini.

# ⚙️ Setup & Installation Instructions

1. **Clone the repository:**
   ```bash
   git clone <repository_url>
   ```

2. **Set up a virtual environment:**
   ```bash
   python3 -m venv .venv
   source .venv/bin/activate  # On Linux/macOS
   .venv\Scripts\activate  # On Windows
   ```

3. **Install dependencies:**
   ```bash
   pip install -r requirements.txt
   ```

4. **Set up environment variables:**
   Create a `.env` file in the root directory and add the following, replacing placeholders with your actual API keys:

   ```
   GEMINI_API_KEY=<your_gemini_api_key>
   GROQ_API_KEY=<your_groq_api_key>
   ```

# 🧩 Explanation of Key Modules, Classes, and Functions

## Python Files

- **`agents/code_generator.py`**: Generates Python code based on a prompt from `input.txt` using Gemini.
- **`agents/reviewer.py`**: Reviews code using the Groq API and saves the review to a file.
- **`agents/optimizer.py`**: Uses the Groq API to provide an optimized version of the code based on the review.
- **`agents/tester.py`**: Generates and runs pytest test cases against the optimized code using the Groq API.
- **`doc-keeper.py`**: Generates documentation for the repository using Gemini.
- **`reviewed_code.py`**: The final, reviewed and optimized version of the generated code. (Generated file)
- **`buggy_code.py`**: The initially generated code from the prompt, intended for review. (Generated file). This file is a copy of `generated_code/generated.py` to trigger the code review workflow separately.
- **`generated_code/generated.py`**: The initially generated code from `input.txt`. (Generated file)
- **`output/fixed_code.py`**: The reviewed and fixed code by the optimizer agent. (Generated file)
- **`output/review.txt`**: The review generated by the optimizer agent. (Generated file)
- **`test_reviewed_code.py`**: The test cases generated for the reviewed code (Generated file)
- **`logs/review_log.txt`**: Log file for the review process. (Generated File)
- **`test_generation.log`**: Log file for test generation. (Generated file).
- **`input.txt`**: Contains the prompt for code generation.
- **`README.md`**: basic project description.
- **`requirements.txt`**: Project dependencies.
- **`.github/workflows`**: Contains GitHub Actions workflow files.
- **`reviews`**: Stores review output files.



## Key Functions (with docstrings):

**`agents/code_generator.py`**:

```python
def read_prompt_from_file(file_path: str = "input.txt") -> str:
    """Reads the plain-text prompt from a .txt file.

    Args:
        file_path (str, optional): Path to the prompt file. Defaults to "input.txt".

    Returns:
        str: The prompt string, or a fallback prompt if the file is not found.
    """
    # ... (Implementation)

def generate_code_from_prompt(prompt: str) -> str:
    """Generates code using Gemini based on the provided prompt.

    Args:
        prompt (str): The prompt for code generation.

    Returns:
        str: The generated code.
    """
    # ... (Implementation)

def main() -> None:
    """Main function to execute the code generation process."""
    # ... (Implementation)
```

**`agents/reviewer.py`**:

```python
def log_message(message: str) -> None:
    """Logs a message with timestamp to log file and prints it.

    Args:
        message (str): The message to log.
    """
    # ... (Implementation)

def read_code_from_file(file_path: str) -> str | None:
    """Reads and returns the code content from the specified file.

    Args:
        file_path (str): Path to the code file.

    Returns:
        str | None: The code content, or None if the file is not found or empty.
    """
    # ... (Implementation)


def review_code(code_content: str) -> str:
    """Sends code to Groq API and returns the code review report.

    Args:
        code_content (str): The code to review.

    Returns:
        str: The code review report.
    """
    # ... (Implementation)

def save_review(review_text: str, original_file: str) -> None:
    """Saves the review report to a file in the reviews folder.

    Args:
        review_text (str): The review text to save.
        original_file (str): Path to the original reviewed file.
    """
    # ... (Implementation)

# ... other functions

```



**`agents/optimizer.py`**:

```python
def extract_code_and_review(response_text: str) -> tuple[str, str]:
    """Extracts code and review explanations from the LLM response.

    Args:
        response_text (str): The raw LLM response.

    Returns:
        tuple[str, str]:  The extracted code and the explanation, respectively.
    """
    # ... (Implementation)

def review_code(code_text: str) -> str:
    """Sends code to Groq API for review and optimization.

    Args:
        code_text (str): Code to review.

    Returns:
        str: API response containing review and optimized code.
    """
    # ... (Implementation)

def process_code(file_path: str) -> None:
    """Reads, reviews, and saves the optimized code.

    Args:
        file_path (str): Path to the code file.
    """
    # ... (Implementation)


```

**`agents/tester.py`**:



```python


def generate_test_cases(code: str) -> str:
    """
    Generates pytest test cases for the provided Python code using the Groq API.

    Args:
        code (str): The Python code to generate tests for.

    Returns:
        str: The generated pytest test code.  Returns an empty string if error.
    """
    # ... implementation ...
```


**`doc-keeper.py`**:

```python
def read_repo_files(base_path: str) -> dict:
    """
    Recursively reads all readable files in the repository directory, excluding
    ignored directories and extensions.

    Parameters:
        base_path (str): The root directory of the repository.

    Returns:
        dict: A dictionary mapping relative file paths to their content.
    """
    # ... (Implementation)

def generate_documentation(repo_files: dict) -> str:
    """
    Generates Markdown documentation using Gemini based on the provided codebase.

    Parameters:
        repo_files (dict): A mapping of file paths to file content.

    Returns:
        str: Generated documentation in Markdown format.
    """
    # ... (Implementation)

def write_documentation(doc_text: str, output_file: str = "DOCUMENTATION.md") -> None:
    """
    Writes generated documentation text to a file.

    Parameters:
        doc_text (str): The markdown content to write to file.
        output_file (str): The path to save the documenation file to. Defaults to DOCUMENTATION.md.
    """
    # ... (Implementation)

# ... other functions
```

# 🗂 Folder & File Structure with Descriptions

```
.
├── .github
│   └── workflows          # GitHub Actions workflow files for code generation, review, optimization, and testing.
│       ├── code-review.yml        # Runs the code review agent.
│       ├── dockeeper.yml         # Triggers the documentation generator.
│       ├── generate-code.yml     # Generates the code based on the input prompt.
│       ├── optimize.yml          # Optimizes the code based on review.
│       └── run-tests.yml         # Runs the generated tests
├── agents                   # Code for automated agents.
│   ├── code_generator.py      # Generates code from input.txt.
│   ├── optimizer.py         # Optimizes code based on review.
│   ├── reviewer.py          # Reviews the generated code.
│   └── tester.py           # Generates tests for the optimized code.
├── generated_code           # The generated Python file will be placed here.
│   └── generated.py
├── logs                    # Log files for the reviewer process.
│   └── review_log.txt      # Contains detailed logging information for code review actions.
├── output                   # Output from the optimzer goes here.
│   ├── fixed_code.py       # Reviewed and fixed code from optimizer.
│   └── review.txt         # Explanation of the changes from the optimizer
├── reviews                 # Review logs for buggy_code.py, generated by reviewer.py.
│   └── buggy_code_review_<timestamp>.txt  # Example of a timestamped code review file.
├── buggy_code.py           # Copy of generated code, acts as trigger for code review.
├── doc-keeper.py           # Generates documentation.
├── DOCUMENTATION.md       # This documentation file. (Generated file)
├── input.txt              # User prompt for code generation.
├── README.md              # Basic project description.
├── requirements.txt        # Project dependency list.
├── reviewed_code.py        # Optimized version of the code after review. (Generated file)
├── test_generation.log     # Log file generated during test case generation and execution. (Generated File)
└── test_reviewed_code.py    # Tests generated by tester.py for reviewed_code.py. (Generated file)

```

# 🔧 How to Use

This project is designed to be run automatically through GitHub Actions. Each workflow is triggered based on specific file changes or the completion of another workflow.

Here's a breakdown of how the workflows work:

1. **Generate Code:** Pushing changes to `input.txt` triggers the "Code Generator on Prompt Input" workflow.  The generated code is placed in `generated_code/generated.py` and copied to `buggy_code.py` to trigger the next workflow.
2. **Code Review:** Pushing changes to `buggy_code.py` triggers the "Code Review" workflow. The generated code is reviewed using the Groq API.  The review report is saved in the `reviews` directory.
3. **Code Optimization:** Successful completion of the "Code Review" workflow automatically triggers the "Code Optimizer" workflow.  The code is optimized based on the review, and the reviewed and optimized code are saved as `reviewed_code.py` and `output/fixed_code.py`. An explanation is also saved to `output/review.txt`.
4. **Test Generation and Execution:** Successful completion of the "Code Optimizer" workflow will trigger the "Run Tests on Reviewed Code" workflow. This uses Groq to generate tests for the reviewed code and then executes these tests with pytest. Test results and logs are saved to `test_generation.log`.
5. **Documentation Generation:**  Pushing any change to the main branch (or a manual trigger) will trigger the "Generate Repository Documentation" workflow. This workflow uses the `doc-keeper.py` script to create or update the `DOCUMENTATION.md` file.


# 🤝 Contribution Guidelines

While this project primarily relies on automated processes, contributions are welcome in areas such as:

* **Improving the prompt engineering:** Enhancing the prompts for code generation, review, optimization, and testing.
* **Refining GitHub Actions workflows:** Optimizing the workflow logic or adding new features.
* **Adding additional agents:** Implementing new agents for different tasks, such as security analysis or code formatting.

# 🧪 Testing & Debugging Instructions

If the tests are not passing, check `test_generation.log` for detailed logs about the generated tests and pytest output.  Also check the review reports in `reviews` and the optimization output in `output/review.txt` and `output/fixed_code.py`.  Manually run `pytest test_reviewed_code.py -v --tb=long` locally to debug test failures.


